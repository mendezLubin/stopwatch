/* Fixing mobile scroll
Need to use height: 100vh so the container fills the screen and centers the stopwatch. But 100vh causes issues on mobile, so I used a solution combining CSS and JS to fix it.
It's ideal to place this code at the very top of your JavaScript file,so it runs as early as possible when the page loads.
This script calculates the actual viewport height and sets it as a CSS variable (--vh).
It fixes the 100vh issue on mobile devices by excluding the browser UI (like the address bar).
The --vh variable is then used in CSS to apply the correct height.
This function runs on load and updates on window resize to keep the value accurate.
*/
function setVh() {
  let vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty("--vh", vh + "px");
}
setVh();
window.addEventListener("resize", setVh);

/*
This timer works more precisely than just using setInterval (calling a function, e.g., every second to increase the count).  
Instead this stopwatch works by consulting (e.g., every second using setInterval) the method performance.now() to check how much time has actually elapsed.  
In this way, we get accurate timing data.
*/

// SELECTIONS:
let selBtnPlay = document.getElementById("btnPlay");
let selBtnPause = document.getElementById("btnPause");
let selBtnReset = document.getElementById("btnReset");
let selHrs = document.getElementById("hrs");
let selMins = document.getElementById("mins");
let selSecs = document.getElementById("secs");
let selCents = document.getElementById("cents");

let idInterval= null; // To save the ID generated by setInterval and use it later with clearInterval
/* This variable is necessary because when we use setInterval(funcCount, 1000) and store it in a variable, it returns an ID. To stop the interval later, we must pass that ID to clearInterval(id).For example: idInterval = setInterval(funcCount, 1000); might return 1, so we later call clearInterval(idInterval) to stop it. 
When there is no counting, no ID is generated — that's why it's initially set to null
*/
let miliSecUntilButtonWasPressed= null; // To save the time elapsed between when the page loaded and when the play button was pressed
let accumulatedElapsedInMiliSec = 0; // For the use of pause

//PLAY

selBtnPlay.addEventListener("click", funcVerifyIfStopWatchIsRunning);

function funcVerifyIfStopWatchIsRunning() {
  // If the counter hasn't started yet, idInterval will be null. 
  // If it's already running, idInterval will have a value. 
  // This prevents errors if the play button is pressed multiple times.
  if (idInterval === null) {
    // In case of error reset everything:
    accumulatedElapsedInMiliSec = 0;
    miliSecUntilButtonWasPressed = null;
    // Display "00:00:00" on screen:
    selSecs.textContent= "00";
    selMins.textContent= "00";
    selHrs.textContent= "00";
    selCents.textContent= "00";

    funcSavemiliSecUntilButtonWasPressed();
    funcExecuteFuncEveryCentisecondAndSaveTheId(); //The id to stop it whe pressing pause
  }
}

function funcSavemiliSecUntilButtonWasPressed() {
    miliSecUntilButtonWasPressed= performance.now(); // Record the time at which the play button was pressed
}

function funcExecuteFuncEveryCentisecondAndSaveTheId() {
    idInterval= setInterval(funcConsultTimeInCentiseconds, 10); // Two things happen in this line of code: when this method is saved in a variable, it provides an ID number that gets stored, and at the same time, it starts calling the function every 10ms to consult the actual timing.
}

function funcConsultTimeInCentiseconds() {
  const nowInMiliSec= performance.now(); // Captures the current time in milliseconds every 10 ms
  const totalElapsedCentSec = Math.floor((accumulatedElapsedInMiliSec + (nowInMiliSec - miliSecUntilButtonWasPressed)) / 10); 
  /* totalElapsedCentSec is the time of the stopwatch in centiseconds:
  - accumulatedElapsedInMiliSec (because when pressing pause we save the time; if not saved, it will be zero) 
  - nowInMiliSec (captures the current time in milliseconds every 10 ms) 
  - miliSecUntilButtonWasPressed (time at which the play button was pressed)
  Divided by 10 to get centiseconds, and all this is rounded to get only centiseconds, not decimals of centiseconds */
  calculateHrsMinsSecs(totalElapsedCentSec);
}

function calculateHrsMinsSecs(totalElapsedCentSec) {
  let seconds= Math.floor(totalElapsedCentSec/100);
  let cents= totalElapsedCentSec % 100;
  let secs= seconds % 60;
  let mins= Math.floor((seconds % 3600) / 60);
  let hrs= Math.floor(seconds / 3600);
  updateDisplay(hrs, mins, secs, cents);

  // Stop the stopwatch when it reaches 99 hours to prevent overflow or excessively long timing.
    if (hrs >= 99) {
    clearInterval(idInterval);
    idInterval = null;
  }
}

function updateDisplay(hrs, mins, secs, cents) {
  selCents.textContent= cents.toString().padStart(2, "0");
  selSecs.textContent= secs.toString().padStart(2, "0");
  selMins.textContent= mins.toString().padStart(2, "0");
  selHrs.textContent= hrs.toString().padStart(2, "0");
  /*padStart(2, "0") ensures the string has at least 2 digits. If the value is less than 2 digits, it adds a leading zero (e.g., "5" becomes "05"). 
  It works only on strings, which is why the value is converted to a string before using padStart. */
}

//PAUSE

selBtnPause.addEventListener("click", funcPause);

// Play & store generated ID → idInterval = setInterval(funcCount, 1000);
// Stop → clearInterval(idInterval);

function funcPause() {
  clearInterval(idInterval); // Stop the interval
  idInterval= null; 
  /* Set to null here because it allows the timer to be resumed later. In the condition if (idInterval === null), if idInterval is null, the function consultTimeEveryCentisecond() will be executed. If it is not null, the condition will not be true, and the function will not be called to continue. */
  accumulatedElapsedInMiliSec = accumulatedElapsedInMiliSec + (performance.now() - miliSecUntilButtonWasPressed);
} 

// RESET

selBtnReset.addEventListener("click", funcReset);

function funcReset() {
  clearInterval(idInterval); // Stop the interval (pause the timer)
  idInterval= null; // Reset the interval ID so the timer can be started again
  accumulatedElapsedInMiliSec = 0; // Reset to cero
  miliSecUntilButtonWasPressed = null;

  // Display "00:00:00" on screen:
  selSecs.textContent= "00";
  selMins.textContent= "00";
  selHrs.textContent= "00";
  selCents.textContent= "00";
}

